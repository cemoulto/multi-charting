
(function (factory) {
    if (typeof module === 'object' && typeof module.exports !== "undefined") {
        module.exports = factory;
    } else {
        factory(MultiCharting);
    }
})(function (MultiCharting) {

	MultiCharting.prototype.createDataStore = function () {
		return new dataStorage(arguments);
	};

	var	lib = MultiCharting.prototype.lib = {},
		dataStore = lib.dataStore = {},
		// For storing the child of a parent
		linkStore = {},
		//For storing the parent of a child
		parentStore = lib.parentStore = {},
		idCount = 0,
		// Constructor class for dataStorage.
		dataStorage = function () {
	    	var manager = this;
	    	manager.addData(arguments);
		},
		dataStoreProto = dataStorage.prototype,

		//Function to update all the linked child data
		updataData = function (id) {
			var i,
				linkData = linkStore[id],
				parentData = dataStore[id],
				filterStore = lib.filterStore,
				len,
				linkIds,
				filters,
				linkId,
				filter,
				filterFn,
				type,
				info,
				// Store all the dataObjs that are updated.
				tempDataUpdated = lib.tempDataUpdated = {};

			linkIds = linkData.link;
			filters = linkData.filter;
			len = linkIds.length;

			for (i = 0; i < len; i++) {
				linkId = linkIds[i];

				tempDataUpdated[linkId] = true;
				filter = filters[i];
				filterFn = filter.getFilter();
				type = filter.type;

				if (typeof filterFn === 'function') {
					if (filterStore[filter.id]) {
						dataStore[linkId] = executeProcessor(type, filterFn, parentData);
					}
					else {
						dataStore[linkId] = parentData;
						filter.splice(i, 1);
						i -= 1;
					}
				}
				
				if (linkStore[linkId]) {
					updataData(linkId);
				}
			}
		},

		executeProcessor = function (type, filterFn, JSONData) {
			switch (type) {
				case  'sort' : return Array.prototype.sort.call(JSONData, filterFn);
					break;
				case  'filter' : return Array.prototype.filter.call(JSONData, filterFn);
					break;
				case 'addInfo' :
				case 'reExpress' : return Array.prototype.map.call(JSONData, filterFn);
					break;
				default : return filterFn(JSONData);
			}
		};

	// Function to add data in the data store
	dataStoreProto.addData = function () {
		var data = this,
			oldId = data.id,
			argument = arguments[0],
			JSONData = argument.data,
			id = argument.id,
			oldJSONData = dataStore[oldId] || [];

		id = oldId || id || 'dataStore' + idCount ++;
		dataStore[id] = oldJSONData.concat(JSONData || []);

		data.id = id;

		if (linkStore[id]) {
			updataData(id)
		}
		dispatchEvent(new CustomEvent('dataAdded', {'detail' : {
			'id': id,
			'data' : JSONData
		}}));
	};

	// Function to get the jsondata of the data object
	dataStoreProto.getJSON = function () {
		return dataStore[this.id];
	};

	// Function to get child data object after applying filter on the parent data.
	// @params {filters} - This can be a filter function or an array of filter functions.
	dataStoreProto.getData = function (filters) {
		var data = this,
			id = data.id,
			filterLink = lib.filterLink;
		// If no parameter is present then return the unfiltered data.
		if (!filters) {
			return dataStore[id];
		}
		// If parameter is an array of filter then return the filtered data after applying the filter over the data.
		else {
			let result = [],
				i,
				newData,
				linkData,
				newId,
				filter,
				filterFn,
				datalinks,
				filterID,
				type,
				isFilterArray = filters instanceof Array,
				len = isFilterArray ? filters.length : 1;

			for (i = 0; i < len; i++) {
				filter = filters[i] || filters;
				filterFn = filter.getFilter();
				type = filter.type;

				if (typeof filterFn === 'function') {
					newData = executeProcessor(type, filterFn, dataStore[id]);

					newDataObj = new dataStorage(newData);
					newId = newDataObj.id;
					parentStore[newId] = data;

					dataStore[newId] = newData;
					result.push(newDataObj);

					//Pushing the id and filter of child class under the parent classes id.
					linkData = linkStore[id] || (linkStore[id] = {
						link : [],
						filter : []
					});
					linkData.link.push(newId);
					linkData.filter.push(filter);

					// Storing the data on which the filter is applied under the filter id.
					filterID = filter.getID();
					datalinks = filterLink[filterID] || (filterLink[filterID] = []);
					datalinks.push(newDataObj)

					// setting the current id as the newID so that the next filter is applied on the child data;
					id = newId;
					data = newDataObj;
				}
			}
			return (isFilterArray ? result : result[0]);
		}
	};

	// Function to delete the current data from the datastore and also all its childs recursively
	dataStoreProto.deleteData = function (optionalId) {
		var data = this,
			id = optionalId || data.id,
			linkData = linkStore[id],
			flag;

		if (linkData) {
			let i,
				link = linkData.link,
				len = link.length;
			for (i = 0; i < len; i ++) {
				data.deleteData(link[i]);
			}
			delete linkStore[id];
		}

		flag = delete dataStore[id];
		dispatchEvent(new CustomEvent('dataDeleted', {'detail' : {
			'id': id,
		}}));
		return flag;
	};

	// Function to get the id of the current data
	dataStoreProto.getID = function () {
		return this.id;
	};

	// Function to modify data
	dataStoreProto.modifyData = function (JSONData) {
		var data = this,
			id = data.id;

		dataStore[id] = [];
		data.addData({
			data : JSONData,
			id : id
		});
		dispatchEvent(new CustomEvent('dataModified', {'detail' : {
			'id': id,
			'data' : JSONData
		}}));
	};
});